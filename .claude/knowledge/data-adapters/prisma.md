# Prisma Data Adapter

How to sync user data from Prisma/PostgreSQL/MySQL projects.

## Detection

Project uses Prisma if ANY of these are true:
- `prisma/schema.prisma` exists
- `package.json` contains `@prisma/client` or `prisma`
- `node_modules/.prisma/` exists

## Schema Discovery

### Step 1: Read Prisma schema

```bash
cat prisma/schema.prisma
```

Look for:
- `model User` or similar user model
- Relations (one-to-many with user)
- Field types and attributes
- `@id`, `@unique`, `@default` decorators

### Step 2: Identify user model and relations

Common patterns:
```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  posts     Post[]
  profile   Profile?
}

model Profile {
  userId String @unique
  user   User   @relation(...)
  tier   String @default("free")
}
```

### Step 3: Map to infrastructure.json

```json
{
  "database": {
    "type": "prisma",
    "provider": "postgresql",
    "models": {
      "User": {
        "idField": "id",
        "fields": ["email", "createdAt", "updatedAt"]
      },
      "Profile": {
        "userIdField": "userId",
        "fields": ["tier", "plan", "onboardingCompleted"]
      },
      "Post": {
        "userIdField": "authorId",
        "countable": true
      }
    }
  }
}
```

## Sync Script Template

**Important:** Requires database connection string in `.env`.

For Prisma projects, we generate a Node.js script (since Prisma client is already installed).

```javascript
#!/usr/bin/env node
/**
 * Prisma User Sync Script
 * Generated by Product OS
 *
 * Prerequisites:
 *   DATABASE_URL set in .env
 *   npx prisma generate (if not done)
 *
 * Usage:
 *   node sync_users.js
 *   node sync_users.js --since=2026-01-12
 */

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

// Parse arguments
const args = process.argv.slice(2);
let sinceDate = null;
for (const arg of args) {
  if (arg.startsWith('--since=')) {
    sinceDate = new Date(arg.split('=')[1]);
  }
}

async function getUsers() {
  const where = sinceDate ? { createdAt: { gte: sinceDate } } : {};

  const users = await prisma.{{USER_MODEL}}.findMany({
    where,
    include: {
      {{PROFILE_RELATION}}: true,
      _count: {
        select: {
          {{ACTIVITY_RELATION}}: true
        }
      }
    },
    orderBy: { createdAt: 'desc' }
  });

  return users.map(user => ({
    id: user.id,
    email: user.email,
    created_at: user.createdAt?.toISOString(),
    last_sign_in: user.lastLoginAt?.toISOString() || null,
    metrics: {
      // From profile
      tier: user.{{PROFILE_RELATION}}?.tier || 'free',
      plan: user.{{PROFILE_RELATION}}?.plan || null,
      // Activity count
      {{ACTIVITY_RELATION}}_count: user._count?.{{ACTIVITY_RELATION}} || 0,
      // Add other discovered fields
      ...extractMetrics(user)
    }
  }));
}

function extractMetrics(user) {
  const metrics = {};
  // Auto-discover metric-like fields
  const metricFields = ['credits', 'tokens', 'usage', 'sessions', 'logins'];
  for (const field of metricFields) {
    if (user[field] !== undefined) {
      metrics[field] = user[field];
    }
  }
  return metrics;
}

async function main() {
  try {
    const users = await getUsers();
    console.log(JSON.stringify(users, null, 2));
  } catch (error) {
    console.error('ERROR:', error.message);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

main();
```

## Alternative: Raw SQL Script (Python)

If user doesn't want to run Node.js script, use raw SQL via Python:

```python
#!/usr/bin/env python3
"""
PostgreSQL/MySQL User Sync Script
Generated by Product OS

Prerequisites:
  DATABASE_URL in .env (postgresql://... or mysql://...)

Usage:
  python3 sync_users.py
  python3 sync_users.py --since=2026-01-12
"""

import json
import sys
import os
from urllib.parse import urlparse

# Parse arguments
since_date = None
for arg in sys.argv[1:]:
    if arg.startswith('--since='):
        since_date = arg.split('=')[1]

# Load .env
def load_env():
    for env_path in ['.env', '.env.local']:
        if os.path.exists(env_path):
            with open(env_path) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        os.environ.setdefault(key.strip(), value.strip().strip('"'))

load_env()

DATABASE_URL = os.environ.get('DATABASE_URL')
if not DATABASE_URL:
    print("ERROR: DATABASE_URL not set", file=sys.stderr)
    sys.exit(1)

# Detect database type
parsed = urlparse(DATABASE_URL)
db_type = parsed.scheme.split('+')[0]  # postgresql, mysql, etc.

if db_type == 'postgresql':
    import psycopg2
    conn = psycopg2.connect(DATABASE_URL)
elif db_type == 'mysql':
    import mysql.connector
    # Parse MySQL URL manually
    conn = mysql.connector.connect(
        host=parsed.hostname,
        user=parsed.username,
        password=parsed.password,
        database=parsed.path[1:]
    )
else:
    print(f"ERROR: Unsupported database type: {db_type}", file=sys.stderr)
    sys.exit(1)

cursor = conn.cursor()

# Build query
query = """
SELECT
    u.id,
    u.email,
    u."createdAt" as created_at,
    p.tier,
    p.plan,
    (SELECT COUNT(*) FROM "{{ACTIVITY_TABLE}}" WHERE "{{USER_ID_FIELD}}" = u.id) as activity_count
FROM "{{USER_TABLE}}" u
LEFT JOIN "{{PROFILE_TABLE}}" p ON p."userId" = u.id
"""

if since_date:
    query += f' WHERE u."createdAt" >= \'{since_date}\''

query += ' ORDER BY u."createdAt" DESC'

cursor.execute(query)
columns = [desc[0] for desc in cursor.description]
rows = cursor.fetchall()

users = []
for row in rows:
    user = dict(zip(columns, row))
    users.append({
        'id': str(user['id']),
        'email': user['email'],
        'created_at': str(user['created_at']) if user['created_at'] else None,
        'metrics': {
            'tier': user.get('tier', 'free'),
            'plan': user.get('plan'),
            'activity_count': user.get('activity_count', 0)
        }
    })

print(json.dumps(users, indent=2, default=str))

cursor.close()
conn.close()
```

## Template Variables

Replace based on `infrastructure.json`:

| Variable | Description | Example |
|----------|-------------|---------|
| `{{USER_MODEL}}` | Prisma model name | `user` (lowercase) |
| `{{USER_TABLE}}` | Database table name | `User` |
| `{{PROFILE_RELATION}}` | Profile relation name | `profile` |
| `{{PROFILE_TABLE}}` | Profile table name | `Profile` |
| `{{ACTIVITY_RELATION}}` | Activity relation name | `posts` |
| `{{ACTIVITY_TABLE}}` | Activity table name | `Post` |
| `{{USER_ID_FIELD}}` | Foreign key to user | `authorId` |

## Incremental Sync

Prisma supports efficient filtering:

```javascript
// Only users created after date
const users = await prisma.user.findMany({
  where: {
    createdAt: { gte: sinceDate }
  }
});

// Or updated after date
const users = await prisma.user.findMany({
  where: {
    OR: [
      { createdAt: { gte: sinceDate } },
      { updatedAt: { gte: sinceDate } }
    ]
  }
});
```

## Common Issues

### "Cannot find module '@prisma/client'"

```bash
npx prisma generate
```

### "DATABASE_URL not set"

Check `.env` file. Common formats:
```
# PostgreSQL
DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"

# MySQL
DATABASE_URL="mysql://user:pass@localhost:3306/mydb"

# SQLite
DATABASE_URL="file:./dev.db"
```

### "Connection refused"

- Check if database is running
- Verify host/port in DATABASE_URL
- Check firewall/network access

## Auto-discovered Metrics

Parse Prisma schema to find metric-like fields:

**Numeric fields (counters):**
- `credits`, `tokens`, `points`
- `loginCount`, `sessionCount`
- `usageMinutes`, `storageBytes`

**Status fields:**
- `tier`, `plan`, `role`
- `status`, `state`
- `isActive`, `isVerified`

**Timestamp fields:**
- `lastLoginAt`, `lastActiveAt`
- `onboardedAt`, `verifiedAt`
- `subscriptionEndsAt`

**Relations to count:**
- `posts`, `comments`, `likes`
- `orders`, `purchases`
- `projects`, `workspaces`

**Auto-detect from schema:**
```javascript
// Find countable relations
const countable = Object.entries(schema.models.User.fields)
  .filter(([_, field]) => field.isList)
  .map(([name]) => name);
```
